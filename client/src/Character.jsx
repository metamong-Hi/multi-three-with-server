/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.2.16 ./public/character.glb -o ./src/Character.jsx 
*/

import React, { useCallback, useEffect, useRef, forwardRef } from 'react'
import { useGLTF, useAnimations, useKeyboardControls, Html } from '@react-three/drei'
import { useControls } from "leva"
import { CapsuleCollider, RigidBody } from '@react-three/rapier';
import { useFrame } from '@react-three/fiber';
import * as THREE from "three"
import "./Character.css"
import { socket } from './ServerConnector';

const CHARACTER_HEIGH = 1.79;
const CAPSULE_RADIUS = 0.3;

const WALK_SPEED = 1;
const RUN_SPEED = 2;

export function ApplyShadow({ refTarget }) {
  useEffect(() => {
    refTarget.current?.traverse((obj) => {
      if (obj.isMesh) {
        obj.castShadow = true;
        obj.receiveShadow = true;
      }
    });
  }, [])
}

function UpdateFrame({ actions, refModel, refRigid, refOrbitControls }) {
  const [ /*subscribeKeys*/, getKeys] = useKeyboardControls();
  const refSpeed = useRef(0);
  const refExceedTime = useRef(0)
  const refPlayingActionName = useRef();
  const playAction = useCallback((actionName) => {
    if (refPlayingActionName.current === actionName) return;
    const action = actions[actionName];
    const prevAction = actions[refPlayingActionName.current];

    action.reset().fadeIn(0.5).play();
    prevAction?.fadeOut(0.5);

    refPlayingActionName.current = actionName;
  }, []);

  const getDirectionOffset = useCallback((keys) => {
    let directionOffset = 0; // w
    if (keys.forward) {
      if (keys.leftward) {
        directionOffset = Math.PI / 4 // w+a (45)
      } else if (keys.rightward) {
        directionOffset = -Math.PI / 4 // w+d (-45)
      }
    } else if (keys.backward) {
      if (keys.leftward) {
        directionOffset = Math.PI / 4 + Math.PI / 2 // s+a (135)
      } else if (keys.rightward) {
        directionOffset = -Math.PI / 4 - Math.PI / 2 // s+d (-135)
      } else {
        directionOffset = Math.PI // s (180)
      }
    } else if (keys.leftward) {
      directionOffset = Math.PI / 2 // a (90)
    } else if (keys.rightward) {
      directionOffset = -Math.PI / 2 // d (-90)
    }
    return directionOffset
  }, []);

  useFrame((state, delta) => {
    const keys = getKeys();

    if (keys.forward || keys.leftward || keys.rightward || keys.backward) {
      if (keys.walk) { // shift
        playAction("Walk");
        refSpeed.current = WALK_SPEED;
      } else {
        playAction("Run");
        refSpeed.current = RUN_SPEED;
      }
    } else {
      playAction("Idle");
      refSpeed.current = 0;
    }

    // 캐릭터가 카메라를 바로보는 방향으로 회전시키기
    const camera = state.camera;
    const model = refModel.current;
    const modelPostion = new THREE.Vector3();
    model.getWorldPosition(modelPostion);
    const angleCameraDirectionAxisY = Math.atan2(
      camera.position.x - modelPostion.x,
      camera.position.z - modelPostion.z
    ) + Math.PI + getDirectionOffset(keys); // getDirectionOffset: 눌러진 키 방향으로 캐릭터 바라보기
    const rotateQuarternion = new THREE.Quaternion();
    const rotationY = angleCameraDirectionAxisY + getDirectionOffset(keys)
    rotateQuarternion.setFromAxisAngle(new THREE.Vector3(0, 1, 0), rotationY)
    model.quaternion.rotateTowards(rotateQuarternion,
      THREE.MathUtils.degToRad(5));

    // 캐릭터 위치 이동(속도에 따라..)
    const walkDirection = new THREE.Vector3();
    camera.getWorldDirection(walkDirection);
    walkDirection.y = 0;
    walkDirection.normalize();
    walkDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0),
      getDirectionOffset(keys));
    const dx = walkDirection.x * refSpeed.current * delta;
    const dz = walkDirection.z * refSpeed.current * delta;
    if (refRigid.current) {
      const cx = refRigid.current.translation().x + dx;
      const cy = refRigid.current.translation().y;
      const cz = refRigid.current.translation().z + dz;
      refRigid.current.setTranslation({ x: cx, y: cy, z: cz });

      // 카메라가 항상 캐릭터를 바라보게 하기
      camera.position.x += dx;
      camera.position.z += dz;
      if (refOrbitControls.current) {
        refOrbitControls.current.target.set(cx, cy, cz);
      }
      refExceedTime.current += delta
      if (refExceedTime.current > 0.2) {
        socket.emit("update", {
          animationName: refPlayingActionName.current,
          position: [cx, cy, cz],
          rotationY: angleCameraDirectionAxisY
        })
        refExceedTime.current = 0
      }
    }
  });
}

function Character({ name = "익명", refOrbitControls, ...props }, refRigid) {
  const group = useRef();
  // const refRigid = useRef();
  const { nodes, materials, animations } = useGLTF('/character.glb')
  const { actions } = useAnimations(animations, group)
  useEffect(() => {
    // refRigid.current.setTranslation({x:props.position[0],y:props.position[1],z:props.position[2]});
  }, [])
  return (
    <>
      <RigidBody lockRotations {...props} ref={refRigid} colliders={false}>
        <CapsuleCollider args={[CHARACTER_HEIGH / 2 - CAPSULE_RADIUS, CAPSULE_RADIUS]} />
        <group ref={group} dispose={null} position-y={-CHARACTER_HEIGH / 2}>
          <group name="Scene">
            <group name="Armature" rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
              <primitive object={nodes.mixamorigHips} />
              <skinnedMesh name="EyeLeft" geometry={nodes.EyeLeft.geometry} material={materials.Wolf3D_Eye} skeleton={nodes.EyeLeft.skeleton} />
              <skinnedMesh name="EyeRight" geometry={nodes.EyeRight.geometry} material={materials.Wolf3D_Eye} skeleton={nodes.EyeRight.skeleton} />
              <skinnedMesh name="Wolf3D_Body" geometry={nodes.Wolf3D_Body.geometry} material={materials.Wolf3D_Body} skeleton={nodes.Wolf3D_Body.skeleton} />
              <skinnedMesh name="Wolf3D_Glasses" geometry={nodes.Wolf3D_Glasses.geometry} material={materials.Wolf3D_Glasses} skeleton={nodes.Wolf3D_Glasses.skeleton} />
              <skinnedMesh name="Wolf3D_Hair" geometry={nodes.Wolf3D_Hair.geometry} material={materials.Wolf3D_Hair} skeleton={nodes.Wolf3D_Hair.skeleton} />
              <skinnedMesh name="Wolf3D_Head" geometry={nodes.Wolf3D_Head.geometry} material={materials.Wolf3D_Skin} skeleton={nodes.Wolf3D_Head.skeleton} />
              <skinnedMesh name="Wolf3D_Outfit_Bottom" geometry={nodes.Wolf3D_Outfit_Bottom.geometry} material={materials.Wolf3D_Outfit_Bottom} skeleton={nodes.Wolf3D_Outfit_Bottom.skeleton} />
              <skinnedMesh name="Wolf3D_Outfit_Footwear" geometry={nodes.Wolf3D_Outfit_Footwear.geometry} material={materials.Wolf3D_Outfit_Footwear} skeleton={nodes.Wolf3D_Outfit_Footwear.skeleton} />
              <skinnedMesh name="Wolf3D_Outfit_Top" geometry={nodes.Wolf3D_Outfit_Top.geometry} material={materials.Wolf3D_Outfit_Top} skeleton={nodes.Wolf3D_Outfit_Top.skeleton} />
              <skinnedMesh name="Wolf3D_Teeth" geometry={nodes.Wolf3D_Teeth.geometry} material={materials.Wolf3D_Teeth} skeleton={nodes.Wolf3D_Teeth.skeleton} />
            </group>
            <Html wrapperClass='character-name'
              position-y={CHARACTER_HEIGH + CHARACTER_HEIGH / 13} center>
              {name}
            </Html>
          </group>
        </group>
      </RigidBody>
      <ApplyShadow refTarget={group} />
      <UpdateFrame actions={actions} refModel={group} refRigid={refRigid}
        refOrbitControls={refOrbitControls} />
    </>
  )
}

export default forwardRef(Character);

useGLTF.preload('/character.glb')
